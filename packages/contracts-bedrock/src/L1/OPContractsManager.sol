// SPDX-License-Identifier: MIT
pragma solidity 0.8.15;

// Contracts
import { OPContractsManagerStandardValidator } from "src/L1/OPContractsManagerStandardValidator.sol";

// Libraries
import { Blueprint } from "src/libraries/Blueprint.sol";
import { Constants } from "src/libraries/Constants.sol";
import { Bytes } from "src/libraries/Bytes.sol";
import { Claim, Duration, GameType, GameTypes, Proposal } from "src/dispute/lib/Types.sol";
import { Strings } from "@openzeppelin/contracts/utils/Strings.sol";
import { SemverComp } from "src/libraries/SemverComp.sol";
import { Features } from "src/libraries/Features.sol";
import { DevFeatures } from "src/libraries/DevFeatures.sol";

// Interfaces
import { ISemver } from "interfaces/universal/ISemver.sol";
import { IResourceMetering } from "interfaces/L1/IResourceMetering.sol";
import { IBigStepper } from "interfaces/dispute/IBigStepper.sol";
import { IDelayedWETH } from "interfaces/dispute/IDelayedWETH.sol";
import { IAnchorStateRegistry } from "interfaces/dispute/IAnchorStateRegistry.sol";
import { IDisputeGame } from "interfaces/dispute/IDisputeGame.sol";
import { IAddressManager } from "interfaces/legacy/IAddressManager.sol";
import { IProxyAdmin } from "interfaces/universal/IProxyAdmin.sol";
import { IDisputeGameFactory } from "interfaces/dispute/IDisputeGameFactory.sol";
import { IFaultDisputeGame } from "interfaces/dispute/IFaultDisputeGame.sol";
import { IPermissionedDisputeGame } from "interfaces/dispute/IPermissionedDisputeGame.sol";
import { ISuperFaultDisputeGame } from "interfaces/dispute/ISuperFaultDisputeGame.sol";
import { ISuperPermissionedDisputeGame } from "interfaces/dispute/ISuperPermissionedDisputeGame.sol";
import { ISuperchainConfig } from "interfaces/L1/ISuperchainConfig.sol";
import { IProtocolVersions } from "interfaces/L1/IProtocolVersions.sol";
import { IOptimismPortal2 as IOptimismPortal } from "interfaces/L1/IOptimismPortal2.sol";
import { IOptimismPortalInterop } from "interfaces/L1/IOptimismPortalInterop.sol";
import { ISystemConfig } from "interfaces/L1/ISystemConfig.sol";
import { IL1CrossDomainMessenger } from "interfaces/L1/IL1CrossDomainMessenger.sol";
import { IL1ERC721Bridge } from "interfaces/L1/IL1ERC721Bridge.sol";
import { IL1StandardBridge } from "interfaces/L1/IL1StandardBridge.sol";
import { IOptimismMintableERC20Factory } from "interfaces/universal/IOptimismMintableERC20Factory.sol";
import { IETHLockbox } from "interfaces/L1/IETHLockbox.sol";

contract OPContractsManagerContractsContainer {
    /// @notice Addresses of the Blueprint contracts.
    /// This is internal because if public the autogenerated getter method would return a tuple of
    /// addresses, but we want it to return a struct.
    OPContractsManager.Blueprints internal blueprint;

    /// @notice Addresses of the latest implementation contracts.
    OPContractsManager.Implementations internal implementation;

    /// @notice Bitmap of development features that are enabled. We keep the development feature
    ///         bitmap here rather than in the actual OPCM because other contracts always get a
    ///         reference to this but not to the OPCM itself.
    bytes32 public immutable devFeatureBitmap;

    /// @notice Thrown when a development feature is enabled in production.
    error OPContractsManagerContractsContainer_DevFeatureInProd();

    /// @param _blueprints The blueprint contract addresses.
    /// @param _implementations The implementation contract addresses.
    /// @param _devFeatureBitmap The bitmap of development features that are enabled.
    constructor(
        OPContractsManager.Blueprints memory _blueprints,
        OPContractsManager.Implementations memory _implementations,
        bytes32 _devFeatureBitmap
    ) {
        blueprint = _blueprints;
        implementation = _implementations;
        devFeatureBitmap = _devFeatureBitmap;

        // Development features MUST NOT be enabled on Mainnet.
        if (block.chainid == 1 && !_isTestingEnvironment() && uint256(_devFeatureBitmap) != 0) {
            revert OPContractsManagerContractsContainer_DevFeatureInProd();
        }
    }

    function blueprints() public view returns (OPContractsManager.Blueprints memory) {
        return blueprint;
    }

    function implementations() public view returns (OPContractsManager.Implementations memory) {
        return implementation;
    }

    /// @notice Returns the status of a development feature. Note that this function does not check
    ///         that the input feature represents a single feature and the bitwise AND operation
    ///         allows for multiple features to be enabled at once. Users should generally check
    ///         for only a single feature at a time.
    /// @param _feature The feature to check.
    /// @return True if the feature is enabled, false otherwise.
    function isDevFeatureEnabled(bytes32 _feature) public view returns (bool) {
        return DevFeatures.isDevFeatureEnabled(devFeatureBitmap, _feature);
    }

    /// @notice Returns true if the contract is running in a testing environment. Checks that the
    ///         code for the address 0xbeefcafe is not zero, which is an address that should never
    ///         have any code in production environments but can be made to have code in tests.
    /// @return True if the contract is running in a testing environment, false otherwise.
    function _isTestingEnvironment() public view returns (bool) {
        return address(0xbeefcafe).code.length > 0;
    }
}

abstract contract OPContractsManagerBase {
    /// @notice Thrown when an invalid game type is used.
    error OPContractsManager_InvalidGameType();

    /// @notice The blueprint contract addresses contract.
    OPContractsManagerContractsContainer public immutable contractsContainer;

    /// @notice The OPContractsManager contract that is currently being used.
    OPContractsManagerBase internal immutable thisOPCM;

    /// @notice Constructor to initialize the immutable thisOPCM variable and contract addresses
    /// @param _contractsContainer The blueprint contract addresses and implementation contract addresses
    constructor(OPContractsManagerContractsContainer _contractsContainer) {
        contractsContainer = _contractsContainer;
        thisOPCM = this;
    }

    /// @notice Retrieves the implementation addresses stored in this OPCM contract
    function getImplementations() internal view returns (OPContractsManager.Implementations memory) {
        return thisOPCM.implementations();
    }

    /// @notice Retrieves the blueprint addresses stored in this OPCM contract
    function getBlueprints() internal view returns (OPContractsManager.Blueprints memory) {
        return thisOPCM.blueprints();
    }

    /// @notice Retrieves the implementation addresses stored in this OPCM contract
    function implementations() public view returns (OPContractsManager.Implementations memory) {
        return contractsContainer.implementations();
    }

    /// @notice Retrieves the blueprint addresses stored in this OPCM contract
    function blueprints() public view returns (OPContractsManager.Blueprints memory) {
        return contractsContainer.blueprints();
    }

    /// @notice Retrieves the development feature bitmap stored in this OPCM contract
    function devFeatureBitmap() public view returns (bytes32) {
        return contractsContainer.devFeatureBitmap();
    }

    /// @notice Retrieves the status of a development feature. Note that this function does not check
    ///         that the input feature represents a single feature and the bitwise AND operation
    ///         allows for multiple features to be enabled at once. Users should generally check
    ///         for only a single feature at a time.
    /// @param _feature The feature to check.
    /// @return True if the feature is enabled, false otherwise.
    function isDevFeatureEnabled(bytes32 _feature) public view returns (bool) {
        return contractsContainer.isDevFeatureEnabled(_feature);
    }

    /// @notice Maps an L2 chain ID to an L1 batch inbox address as defined by the standard
    /// configuration's convention. This convention is `versionByte || keccak256(bytes32(chainId))[:19]`,
    /// where || denotes concatenation`, versionByte is 0x00, and chainId is a uint256.
    /// https://specs.optimism.io/protocol/configurability.html#consensus-parameters
    function chainIdToBatchInboxAddress(uint256 _l2ChainId) public pure returns (address) {
        bytes1 versionByte = 0x00;
        bytes32 hashedChainId = keccak256(bytes.concat(bytes32(_l2ChainId)));
        bytes19 first19Bytes = bytes19(hashedChainId);
        return address(uint160(bytes20(bytes.concat(versionByte, first19Bytes))));
    }

    /// @notice Helper method for computing a salt that's used in CREATE2 deployments.
    /// Including the contract name ensures that the resultant address from CREATE2 is unique
    /// across our smart contract system. For example, we deploy multiple proxy contracts
    /// with the same bytecode from this contract, so they each require a unique salt for determinism.
    function computeSalt(
        uint256 _l2ChainId,
        string memory _saltMixer,
        string memory _contractName
    )
        internal
        pure
        returns (bytes32)
    {
        return keccak256(abi.encode(_l2ChainId, _saltMixer, _contractName));
    }

    /// @notice Helper method for computing a reusable salt mixer
    /// This method should be used as the salt mixer when deploying contracts when there is no user
    /// provided salt mixer. This protects against a situation where multiple chains with the same
    /// L2 chain ID exist, which would otherwise result in address collisions.
    /// @param _systemConfigProxy The SystemConfig contract found in the OpChainConfig of the chain being deployed to.
    function reusableSaltMixer(ISystemConfig _systemConfigProxy) internal pure returns (string memory) {
        return string(bytes.concat(bytes32(uint256(uint160(address(_systemConfigProxy))))));
    }

    /// @notice Deterministically deploys a new proxy contract owned by the provided ProxyAdmin.
    /// The salt is computed as a function of the L2 chain ID, the salt mixer and the contract name.
    /// This is required because we deploy many identical proxies, so they each require a unique salt for determinism.
    function deployProxy(
        uint256 _l2ChainId,
        IProxyAdmin _proxyAdmin,
        string memory _saltMixer,
        string memory _contractName
    )
        internal
        returns (address)
    {
        bytes32 salt = computeSalt(_l2ChainId, _saltMixer, _contractName);
        return Blueprint.deployFrom(getBlueprints().proxy, salt, abi.encode(_proxyAdmin));
    }

    /// @notice Makes an internal call to the target to initialize the proxy with the specified data.
    /// First performs safety checks to ensure the target, implementation, and proxy admin are valid.
    function upgradeToAndCall(
        IProxyAdmin _proxyAdmin,
        address _target,
        address _implementation,
        bytes memory _data
    )
        internal
    {
        assertValidContractAddress(_implementation);

        _proxyAdmin.upgradeAndCall(payable(address(_target)), _implementation, _data);
    }

    function assertValidContractAddress(address _who) public view {
        if (_who.code.length == 0) revert OPContractsManager.AddressHasNoCode(_who);
    }

    function encodePermissionlessFDGConstructor(IFaultDisputeGame.GameConstructorParams memory _params)
        internal
        view
        virtual
        returns (bytes memory)
    {
        bytes memory dataWithSelector = abi.encodeCall(IFaultDisputeGame.__constructor__, (_params));
        return Bytes.slice(dataWithSelector, 4);
    }

    function encodePermissionedFDGConstructor(
        IFaultDisputeGame.GameConstructorParams memory _params,
        address _proposer,
        address _challenger
    )
        internal
        view
        virtual
        returns (bytes memory)
    {
        bytes memory dataWithSelector =
            abi.encodeCall(IPermissionedDisputeGame.__constructor__, (_params, _proposer, _challenger));
        return Bytes.slice(dataWithSelector, 4);
    }

    function encodePermissionlessSuperFDGConstructor(ISuperFaultDisputeGame.GameConstructorParams memory _params)
        internal
        view
        virtual
        returns (bytes memory)
    {
        bytes memory dataWithSelector = abi.encodeCall(ISuperFaultDisputeGame.__constructor__, (_params));
        return Bytes.slice(dataWithSelector, 4);
    }

    function encodePermissionedSuperFDGConstructor(
        ISuperFaultDisputeGame.GameConstructorParams memory _params,
        address _proposer,
        address _challenger
    )
        internal
        view
        virtual
        returns (bytes memory)
    {
        bytes memory dataWithSelector =
            abi.encodeCall(ISuperPermissionedDisputeGame.__constructor__, (_params, _proposer, _challenger));
        return Bytes.slice(dataWithSelector, 4);
    }

    /// @notice Returns the implementation contract address for a given game type.
    function getGameImplementation(
        IDisputeGameFactory _disputeGameFactory,
        GameType _gameType
    )
        internal
        view
        returns (IDisputeGame)
    {
        return _disputeGameFactory.gameImpls(_gameType);
    }

    /// @notice Retrieves the Anchor State Registry for a given game
    function getAnchorStateRegistry(IFaultDisputeGame _disputeGame) internal view returns (IAnchorStateRegistry) {
        return _disputeGame.anchorStateRegistry();
    }

    /// @notice Retrieves the L2 chain ID for a given game
    function getL2ChainId(IFaultDisputeGame _disputeGame) internal view returns (uint256) {
        return _disputeGame.l2ChainId();
    }

    /// @notice Retrieves the proposer address for a given game
    function getProposer(IPermissionedDisputeGame _disputeGame) internal view returns (address) {
        return _disputeGame.proposer();
    }

    /// @notice Retrieves the challenger address for a given game
    function getChallenger(IPermissionedDisputeGame _disputeGame) internal view returns (address) {
        return _disputeGame.challenger();
    }

    /// @notice Retrieves the DisputeGameFactory address for a given SystemConfig
    function getDisputeGameFactory(ISystemConfig _systemConfig) internal view returns (IDisputeGameFactory) {
        return IDisputeGameFactory(_systemConfig.disputeGameFactory());
    }

    /// @notice Retrieves the AnchorStateRegistry address for a given SystemConfig
    function getAnchorStateRegistry(ISystemConfig _systemConfig) internal view returns (IAnchorStateRegistry) {
        return IAnchorStateRegistry(IOptimismPortal(payable(_systemConfig.optimismPortal())).anchorStateRegistry());
    }

    /// @notice Retrieves the constructor params for a given game.
    function getGameConstructorParams(IFaultDisputeGame _disputeGame)
        internal
        view
        returns (IFaultDisputeGame.GameConstructorParams memory)
    {
        // Grab the game type first, it'll determine if we need to pull the L2 chain ID from the
        // contract or if we just return zero (Super games).
        GameType gameType = _disputeGame.gameType();

        // If the game type is a Super game, then we don't need to pull the L2 chain ID from the
        // contract.
        uint256 l2ChainId;
        if (
            gameType.raw() == GameTypes.SUPER_CANNON.raw()
                || gameType.raw() == GameTypes.SUPER_PERMISSIONED_CANNON.raw()
                || gameType.raw() == GameTypes.SUPER_CANNON_KONA.raw()
        ) {
            l2ChainId = 0;
        } else {
            l2ChainId = getL2ChainId(_disputeGame);
        }

        // Return the constructor params.
        return IFaultDisputeGame.GameConstructorParams({
            gameType: gameType,
            absolutePrestate: _disputeGame.absolutePrestate(),
            maxGameDepth: _disputeGame.maxGameDepth(),
            splitDepth: _disputeGame.splitDepth(),
            clockExtension: _disputeGame.clockExtension(),
            maxClockDuration: _disputeGame.maxClockDuration(),
            vm: _disputeGame.vm(),
            weth: getWETH(_disputeGame),
            anchorStateRegistry: getAnchorStateRegistry(_disputeGame),
            l2ChainId: l2ChainId
        });
    }

    /// @notice Retrieves the DelayedWETH address for a given game
    function getWETH(IFaultDisputeGame _disputeGame) internal view returns (IDelayedWETH) {
        return _disputeGame.weth();
    }

    /// @notice Sets a game implementation on the dispute game factory
    function setDGFImplementation(IDisputeGameFactory _dgf, GameType _gameType, IDisputeGame _newGame) internal {
        _dgf.setImplementation(_gameType, _newGame);
    }
}

contract OPContractsManagerGameTypeAdder is OPContractsManagerBase {
    /// @notice Thrown when an unsupported game type is provided to the addGameType function.
    error OPContractsManagerGameTypeAdder_UnsupportedGameType();

    /// @notice Thrown when a mix of legacy and super games are found in updatePrestate.
    error OPContractsManagerGameTypeAdder_MixedGameTypes();

    /// @notice Emitted when a new game type is added to a chain
    /// @param l2ChainId Chain ID of the chain
    /// @param gameType Type of the game being
    /// @param newDisputeGame Address of the deployed dispute game
    /// @param oldDisputeGame Address of the old dispute game
    event GameTypeAdded(
        uint256 indexed l2ChainId, GameType indexed gameType, IDisputeGame newDisputeGame, IDisputeGame oldDisputeGame
    );

    /// @notice Constructor to initialize the immutable thisOPCM variable and contract addresses
    /// @param _contractsContainer The blueprint contract addresses and implementation contract addresses
    constructor(OPContractsManagerContractsContainer _contractsContainer) OPContractsManagerBase(_contractsContainer) { }

    /// @notice Deploys a new dispute game and installs it into the DisputeGameFactory. Inputted
    ///         game configs must be added in ascending GameType order.
    /// @param _gameConfigs Game configs to add.
    /// @return Array of results for the operations performed.
    function addGameType(OPContractsManager.AddGameInput[] memory _gameConfigs)
        public
        virtual
        returns (OPContractsManager.AddGameOutput[] memory)
    {
        // Ensure we have at least one game config to add.
        if (_gameConfigs.length == 0) revert OPContractsManager.InvalidGameConfigs();

        // We'll have one output per game config.
        OPContractsManager.AddGameOutput[] memory outputs = new OPContractsManager.AddGameOutput[](_gameConfigs.length);

        // Store last game config as an int256 so that we can ensure that the same game config is
        // not added twice. Using int256 generates cheaper, simpler bytecode.
        int256 lastGameConfig = -1;

        // Loop through each game config and add the game type.
        for (uint256 i = 0; i < _gameConfigs.length; i++) {
            OPContractsManager.AddGameInput memory gameConfig = _gameConfigs[i];

            // This conversion is safe because the GameType is a uint32, which will always fit in
            // an int256.
            int256 gameTypeInt = int256(uint256(gameConfig.disputeGameType.raw()));

            // Ensure that the game configs are added in ascending order, and not duplicated.
            if (lastGameConfig >= gameTypeInt) revert OPContractsManager.InvalidGameConfigs();
            lastGameConfig = gameTypeInt;

            // Grab the L2 chain ID from the SystemConfig.
            uint256 l2ChainId = gameConfig.systemConfig.l2ChainId();

            // Deploy a new DelayedWETH proxy for this game if one hasn't already been specified.
            // Leaving gameConfig.delayedWETH as the zero address will cause a new DelayedWETH to
            // be deployed for this game.
            if (address(gameConfig.delayedWETH) == address(0)) {
                // Deploy the DelayedWETH proxy. We use the chain ID and the game type in the
                // contract name to ensure that the contract is unique across chains.
                outputs[i].delayedWETH = IDelayedWETH(
                    payable(
                        deployProxy(
                            l2ChainId,
                            gameConfig.proxyAdmin,
                            gameConfig.saltMixer,
                            string.concat("DelayedWETH-", Strings.toString(uint256(gameTypeInt)))
                        )
                    )
                );

                // Initialize the proxy.
                upgradeToAndCall(
                    gameConfig.proxyAdmin,
                    address(outputs[i].delayedWETH),
                    getImplementations().delayedWETHImpl,
                    abi.encodeCall(IDelayedWETH.initialize, (gameConfig.systemConfig))
                );
            } else {
                outputs[i].delayedWETH = gameConfig.delayedWETH;
            }

            // Determine the contract name and blueprints for the game type.
            string memory gameContractName;
            address blueprint1;
            address blueprint2;
            uint256 gameL2ChainId;

            // Separate context to avoid stack too deep.
            {
                // Grab the blueprints once since we'll need it multiple times below.
                OPContractsManager.Blueprints memory bps = getBlueprints();

                // Determine the contract name and blueprints for the game type.
                if (
                    gameConfig.disputeGameType.raw() == GameTypes.CANNON.raw()
                        || (
                            isDevFeatureEnabled(DevFeatures.CANNON_KONA)
                                && gameConfig.disputeGameType.raw() == GameTypes.CANNON_KONA.raw()
                        )
                ) {
                    gameContractName = "FaultDisputeGame";
                    blueprint1 = bps.permissionlessDisputeGame1;
                    blueprint2 = bps.permissionlessDisputeGame2;
                    gameL2ChainId = l2ChainId;
                } else if (gameConfig.disputeGameType.raw() == GameTypes.PERMISSIONED_CANNON.raw()) {
                    gameContractName = "PermissionedDisputeGame";
                    blueprint1 = bps.permissionedDisputeGame1;
                    blueprint2 = bps.permissionedDisputeGame2;
                    gameL2ChainId = l2ChainId;
                } else if (
                    gameConfig.disputeGameType.raw() == GameTypes.SUPER_CANNON.raw()
                        || (
                            isDevFeatureEnabled(DevFeatures.CANNON_KONA)
                                && gameConfig.disputeGameType.raw() == GameTypes.SUPER_CANNON_KONA.raw()
                        )
                ) {
                    gameContractName = "SuperFaultDisputeGame";
                    blueprint1 = bps.superPermissionlessDisputeGame1;
                    blueprint2 = bps.superPermissionlessDisputeGame2;
                    gameL2ChainId = 0;
                } else if (gameConfig.disputeGameType.raw() == GameTypes.SUPER_PERMISSIONED_CANNON.raw()) {
                    gameContractName = "SuperPermissionedDisputeGame";
                    blueprint1 = bps.superPermissionedDisputeGame1;
                    blueprint2 = bps.superPermissionedDisputeGame2;
                    gameL2ChainId = 0;
                } else {
                    revert OPContractsManagerGameTypeAdder_UnsupportedGameType();
                }
            }

            // Grab the DisputeGameFactory and AnchorStateRegistry for the chain.
            IDisputeGameFactory dgf = getDisputeGameFactory(gameConfig.systemConfig);

            // Grab the existing game implementation from the DisputeGameFactory.
            IFaultDisputeGame existingGame =
                IFaultDisputeGame(address(getGameImplementation(dgf, gameConfig.disputeGameType)));

            // Encode the constructor data for the game type.
            bytes memory constructorData;
            if (gameConfig.permissioned) {
                constructorData = encodePermissionedFDGConstructor(
                    IFaultDisputeGame.GameConstructorParams(
                        gameConfig.disputeGameType,
                        gameConfig.disputeAbsolutePrestate,
                        gameConfig.disputeMaxGameDepth,
                        gameConfig.disputeSplitDepth,
                        gameConfig.disputeClockExtension,
                        gameConfig.disputeMaxClockDuration,
                        gameConfig.vm,
                        outputs[i].delayedWETH,
                        getAnchorStateRegistry(gameConfig.systemConfig),
                        gameL2ChainId
                    ),
                    getProposer(IPermissionedDisputeGame(address(existingGame))),
                    getChallenger(IPermissionedDisputeGame(address(existingGame)))
                );
            } else {
                constructorData = encodePermissionlessFDGConstructor(
                    IFaultDisputeGame.GameConstructorParams(
                        gameConfig.disputeGameType,
                        gameConfig.disputeAbsolutePrestate,
                        gameConfig.disputeMaxGameDepth,
                        gameConfig.disputeSplitDepth,
                        gameConfig.disputeClockExtension,
                        gameConfig.disputeMaxClockDuration,
                        gameConfig.vm,
                        outputs[i].delayedWETH,
                        getAnchorStateRegistry(gameConfig.systemConfig),
                        gameL2ChainId
                    )
                );
            }

            // Deploy the new game type.
            outputs[i].faultDisputeGame = IFaultDisputeGame(
                Blueprint.deployFrom(
                    blueprint1,
                    blueprint2,
                    computeSalt(l2ChainId, gameConfig.saltMixer, gameContractName),
                    constructorData
                )
            );

            // As a last step, register the new game type with the DisputeGameFactory. If the game
            // type already exists, then its implementation will be overwritten.
            setDGFImplementation(dgf, gameConfig.disputeGameType, IDisputeGame(address(outputs[i].faultDisputeGame)));
            dgf.setInitBond(gameConfig.disputeGameType, gameConfig.initialBond);

            // Emit event for the newly added game type with the new and old implementations.
            emit GameTypeAdded(
                l2ChainId, gameConfig.disputeGameType, outputs[i].faultDisputeGame, IDisputeGame(address(existingGame))
            );
        }

        return outputs;
    }

    /// @notice Updates the prestate hash for all deployed dispute games while keeping all other game
    ///         parameters exactly the same. Currently requires deploying a new implementation
    ///         as there is no way to update the prestate on an existing implementation.
    /// @param _prestateUpdateInputs The new prestate hash to use.
    function updatePrestate(OPContractsManager.UpdatePrestateInput[] memory _prestateUpdateInputs) public {
        // Loop through each chain and prestate hash
        for (uint256 i = 0; i < _prestateUpdateInputs.length; i++) {
            // Grab the DisputeGameFactory.
            IDisputeGameFactory dgf =
                IDisputeGameFactory(_prestateUpdateInputs[i].systemConfigProxy.disputeGameFactory());

            uint256 numGameTypes = isDevFeatureEnabled(DevFeatures.CANNON_KONA) ? 6 : 4;
            // Create an array of all of the potential game types to update.
            GameType[] memory gameTypes = new GameType[](numGameTypes);
            gameTypes[0] = GameTypes.CANNON;
            gameTypes[1] = GameTypes.PERMISSIONED_CANNON;
            gameTypes[2] = GameTypes.SUPER_CANNON;
            gameTypes[3] = GameTypes.SUPER_PERMISSIONED_CANNON;
            if (isDevFeatureEnabled(DevFeatures.CANNON_KONA)) {
                gameTypes[4] = GameTypes.CANNON_KONA;
                gameTypes[5] = GameTypes.SUPER_CANNON_KONA;
            }

            // Track if we have a legacy game, super game, or both. We will revert if this function
            // is ever called with a mix of legacy and super games. Should never happen in
            // production if you follow the standard upgrade process, but you never know.
            bool hasLegacyGame = false;
            bool hasSuperGame = false;

            // Iterate over each game type and update the prestate.
            for (uint256 j = 0; j < gameTypes.length; j++) {
                GameType gameType = gameTypes[j];

                // Get the existing game implementation.
                IFaultDisputeGame existingGame = IFaultDisputeGame(address(getGameImplementation(dgf, gameType)));

                // If no implementation exists, skip.
                if (address(existingGame) == address(0)) {
                    continue;
                }

                // Track the game types that we've seen so far.
                if (
                    gameType.raw() == GameTypes.SUPER_CANNON.raw()
                        || gameType.raw() == GameTypes.SUPER_PERMISSIONED_CANNON.raw()
                        || gameType.raw() == GameTypes.SUPER_CANNON_KONA.raw()
                ) {
                    hasSuperGame = true;
                } else {
                    hasLegacyGame = true;
                }

                // If we have a mix of legacy and super games, revert.
                if (hasLegacyGame && hasSuperGame) {
                    revert OPContractsManagerGameTypeAdder_MixedGameTypes();
                }

                // Select the prestate to use
                Claim prestate = gameType.raw() == GameTypes.CANNON_KONA.raw()
                    || gameType.raw() == GameTypes.SUPER_CANNON_KONA.raw()
                    ? _prestateUpdateInputs[i].cannonKonaPrestate
                    : _prestateUpdateInputs[i].cannonPrestate;

                // Ensure that the prestate is not the zero hash.
                if (Claim.unwrap(prestate) == bytes32(0)) {
                    revert OPContractsManager.PrestateRequired();
                }

                // Grab the existing game constructor params and init bond.
                IFaultDisputeGame.GameConstructorParams memory gameParams = getGameConstructorParams(existingGame);

                // Create a new game input with the updated prestate.
                OPContractsManager.AddGameInput memory input = OPContractsManager.AddGameInput({
                    disputeAbsolutePrestate: prestate,
                    saltMixer: reusableSaltMixer(_prestateUpdateInputs[i].systemConfigProxy),
                    systemConfig: _prestateUpdateInputs[i].systemConfigProxy,
                    proxyAdmin: _prestateUpdateInputs[i].systemConfigProxy.proxyAdmin(),
                    delayedWETH: IDelayedWETH(payable(address(gameParams.weth))),
                    disputeGameType: gameParams.gameType,
                    disputeMaxGameDepth: gameParams.maxGameDepth,
                    disputeSplitDepth: gameParams.splitDepth,
                    disputeClockExtension: gameParams.clockExtension,
                    disputeMaxClockDuration: gameParams.maxClockDuration,
                    initialBond: dgf.initBonds(gameType),
                    vm: gameParams.vm,
                    permissioned: gameType.raw() == GameTypes.PERMISSIONED_CANNON.raw()
                        || gameType.raw() == GameTypes.SUPER_PERMISSIONED_CANNON.raw()
                });

                // Add the new game type with updated prestate
                OPContractsManager.AddGameInput[] memory inputs = new OPContractsManager.AddGameInput[](1);
                inputs[0] = input;
                addGameType(inputs);
            }
        }
    }
}

contract OPContractsManagerUpgrader is OPContractsManagerBase {
    /// @notice Emitted when a chain is upgraded
    /// @param systemConfig Address of the chain's SystemConfig contract
    /// @param upgrader Address that initiated the upgrade
    event Upgraded(uint256 indexed l2ChainId, ISystemConfig indexed systemConfig, address indexed upgrader);

    /// @notice Thrown when the SuperchainConfig contract does not match the unified config.
    error OPContractsManagerUpgrader_SuperchainConfigMismatch();

    /// @notice Thrown when upgrade is called with a chain whose superchainConfig is not upgraded.
    error OPContractsManagerUpgrader_SuperchainConfigNeedsUpgrade(uint256 index);

    /// @notice Thrown when upgradeSuperchainConfig is called with a superchainConfig that is already up to date.
    error OPContractsManagerUpgrader_SuperchainConfigAlreadyUpToDate();

    /// @param _contractsContainer The OPContractsManagerContractsContainer to use.
    constructor(OPContractsManagerContractsContainer _contractsContainer) OPContractsManagerBase(_contractsContainer) { }

    /// @notice Upgrades a set of chains to the latest implementation contracts
    /// @param _opChainConfigs Array of OpChain structs, one per chain to upgrade
    /// @dev This function is intended to be DELEGATECALLed by an address that is the common owner of every chain in
    ///      `_opChainConfigs`'s ProxyAdmin.
    /// @dev This function requires that each chain's superchainConfig is already upgraded.
    function upgrade(OPContractsManager.OpChainConfig[] memory _opChainConfigs) external virtual {
        // Grab the implementations.
        OPContractsManager.Implementations memory impls = getImplementations();

        // Loop through each chain and upgrade.
        for (uint256 i = 0; i < _opChainConfigs.length; i++) {
            assertValidOpChainConfig(_opChainConfigs[i]);
            uint256 l2ChainId = _opChainConfigs[i].systemConfigProxy.l2ChainId();

            // Grab the SuperchainConfig.
            ISuperchainConfig superchainConfig = _opChainConfigs[i].systemConfigProxy.superchainConfig();

            // If the SuperchainConfig is not already upgraded, revert.
            if (SemverComp.lt(superchainConfig.version(), ISuperchainConfig(impls.superchainConfigImpl).version())) {
                revert OPContractsManagerUpgrader_SuperchainConfigNeedsUpgrade(i);
            }

            // Do the chain upgrade.
            // All of your updates should be done in this internal function unless you're making a
            // change to how upgrades work in general.
            _doChainUpgrade(impls, _opChainConfigs[i], l2ChainId);

            // Emit the upgraded event with the address of the caller. Since this will be a delegatecall,
            // the caller will be the value of the ADDRESS opcode.
            emit Upgraded(l2ChainId, _opChainConfigs[i].systemConfigProxy, address(this));
        }
    }

    /// @notice Performs an upgrade for a specific chain.
    /// @param _impls The implementations of the contracts.
    /// @param _opChainConfig The configuration of the chain to upgrade.
    /// @param _l2ChainId The L2 chain ID of the chain to upgrade.
    function _doChainUpgrade(
        OPContractsManager.Implementations memory _impls,
        OPContractsManager.OpChainConfig memory _opChainConfig,
        uint256 _l2ChainId
    )
        internal
    {
        // Upgrade the SystemConfig first.
        upgradeTo(_opChainConfig.proxyAdmin, address(_opChainConfig.systemConfigProxy), _impls.systemConfigImpl);

        // Grab the OptimismPortal contract.
        IOptimismPortal optimismPortal = IOptimismPortal(payable(_opChainConfig.systemConfigProxy.optimismPortal()));

        // Upgrade the OptimismPortal contract.
        if (isDevFeatureEnabled(DevFeatures.OPTIMISM_PORTAL_INTEROP)) {
            // This does NOT run in production.
            // Upgrade the OptimismPortal contract implementation.
            upgradeTo(_opChainConfig.proxyAdmin, address(optimismPortal), _impls.optimismPortalInteropImpl);

            // If we don't already have an ETHLockbox, deploy and initialize it.
            IETHLockbox ethLockbox = optimismPortal.ethLockbox();
            if (address(ethLockbox) == address(0)) {
                // Deploy the ETHLockbox proxy.
                ethLockbox = IETHLockbox(
                    deployProxy({
                        _l2ChainId: _l2ChainId,
                        _proxyAdmin: _opChainConfig.proxyAdmin,
                        _saltMixer: reusableSaltMixer(_opChainConfig.systemConfigProxy),
                        _contractName: "ETHLockbox-U16a"
                    })
                );

                // Initialize the ETHLockbox setting the OptimismPortal as an authorized portal.
                IOptimismPortal[] memory portals = new IOptimismPortal[](1);
                portals[0] = optimismPortal;
                upgradeToAndCall(
                    _opChainConfig.proxyAdmin,
                    address(ethLockbox),
                    _impls.ethLockboxImpl,
                    abi.encodeCall(IETHLockbox.initialize, (_opChainConfig.systemConfigProxy, portals))
                );

                // Migrate liquidity from the OptimismPortal to the ETHLockbox.
                IOptimismPortalInterop(payable(optimismPortal)).migrateLiquidity();
            }

            // Use the existing AnchorStateRegistry reference.
            IAnchorStateRegistry anchorStateRegistry = optimismPortal.anchorStateRegistry();

            // Upgrade the OptimismPortal contract first so that the SystemConfig will have
            // the SuperchainConfig reference required in the ETHLockbox.
            IOptimismPortalInterop(payable(optimismPortal)).upgrade(anchorStateRegistry, ethLockbox);
        } else {
            // This runs in production.
            upgradeTo(_opChainConfig.proxyAdmin, address(optimismPortal), _impls.optimismPortalImpl);
        }

        // Upgrade the OptimismMintableERC20Factory contract.
        upgradeTo(
            _opChainConfig.proxyAdmin,
            _opChainConfig.systemConfigProxy.optimismMintableERC20Factory(),
            _impls.optimismMintableERC20FactoryImpl
        );

        // Use the SystemConfig to grab the DisputeGameFactory address.
        IDisputeGameFactory dgf = IDisputeGameFactory(_opChainConfig.systemConfigProxy.disputeGameFactory());

        // Need to upgrade the DisputeGameFactory implementation, no internal upgrade call.
        upgradeTo(_opChainConfig.proxyAdmin, address(dgf), _impls.disputeGameFactoryImpl);

        // Separate context to avoid stack too deep.
        {
            // Grab chain addresses here. We need to do this after the SystemConfig upgrade or
            // the addresses will be incorrect.
            ISystemConfig.Addresses memory opChainAddrs = _opChainConfig.systemConfigProxy.getAddresses();

            // Upgrade the L1CrossDomainMessenger contract.
            upgradeTo(
                _opChainConfig.proxyAdmin,
                address(IL1CrossDomainMessenger(opChainAddrs.l1CrossDomainMessenger)),
                _impls.l1CrossDomainMessengerImpl
            );

            // Upgrade the L1StandardBridge contract.
            upgradeTo(
                _opChainConfig.proxyAdmin,
                address(IL1StandardBridge(payable(opChainAddrs.l1StandardBridge))),
                _impls.l1StandardBridgeImpl
            );

            // Upgrade the L1ERC721Bridge contract.
            upgradeTo(
                _opChainConfig.proxyAdmin,
                address(IL1ERC721Bridge(opChainAddrs.l1ERC721Bridge)),
                _impls.l1ERC721BridgeImpl
            );
        }

        // All chains have the PermissionedDisputeGame, grab that.
        IPermissionedDisputeGame permissionedDisputeGame =
            IPermissionedDisputeGame(address(getGameImplementation(dgf, GameTypes.PERMISSIONED_CANNON)));

        // Update the PermissionedDisputeGame.
        // We're reusing the same DelayedWETH and ASR contracts.
        deployAndSetNewGameImpl({
            _l2ChainId: _l2ChainId,
            _disputeGame: IDisputeGame(address(permissionedDisputeGame)),
            _newDelayedWeth: permissionedDisputeGame.weth(),
            _newAnchorStateRegistryProxy: permissionedDisputeGame.anchorStateRegistry(),
            _gameType: GameTypes.PERMISSIONED_CANNON,
            _opChainConfig: _opChainConfig
        });

        // Now retrieve the permissionless game.
        IFaultDisputeGame permissionlessDisputeGame =
            IFaultDisputeGame(address(getGameImplementation(dgf, GameTypes.CANNON)));

        // If it exists, replace its implementation.
        // We're reusing the same DelayedWETH and ASR contracts.
        if (address(permissionlessDisputeGame) != address(0)) {
            deployAndSetNewGameImpl({
                _l2ChainId: _l2ChainId,
                _disputeGame: IDisputeGame(address(permissionlessDisputeGame)),
                _newDelayedWeth: permissionlessDisputeGame.weth(),
                _newAnchorStateRegistryProxy: permissionlessDisputeGame.anchorStateRegistry(),
                _gameType: GameTypes.CANNON,
                _opChainConfig: _opChainConfig
            });
        }
    }

    /// @notice Upgrades the SuperchainConfig contract.
    /// @param _superchainConfig The SuperchainConfig contract to upgrade.
    /// @param _superchainProxyAdmin The ProxyAdmin contract to use for the upgrade.
    /// @dev This function is intended to be DELEGATECALLed by the superchainConfig's ProxyAdminOwner.
    /// @dev This function will revert if the SuperchainConfig is already at or above the target version.
    function upgradeSuperchainConfig(ISuperchainConfig _superchainConfig, IProxyAdmin _superchainProxyAdmin) external {
        // Only upgrade the superchainConfig if the current version is less than the target version.
        if (
            SemverComp.gte(
                _superchainConfig.version(), ISuperchainConfig(getImplementations().superchainConfigImpl).version()
            )
        ) {
            revert OPContractsManagerUpgrader_SuperchainConfigAlreadyUpToDate();
        }

        // Grab the implementations.
        OPContractsManager.Implementations memory impls = getImplementations();

        // Attempt to upgrade. If the ProxyAdmin is not the SuperchainConfig's admin, this will revert.
        upgradeTo(_superchainProxyAdmin, address(_superchainConfig), impls.superchainConfigImpl);
    }

    /// @notice Updates the implementation of a proxy without calling the initializer.
    /// First performs safety checks to ensure the target, implementation, and proxy admin are valid.
    function upgradeTo(IProxyAdmin _proxyAdmin, address _target, address _implementation) internal {
        assertValidContractAddress(_implementation);

        _proxyAdmin.upgrade(payable(address(_target)), _implementation);
    }

    /// @notice Verifies that all OpChainConfig inputs are valid and reverts if any are invalid.
    function assertValidOpChainConfig(OPContractsManager.OpChainConfig memory _config) internal view {
        assertValidContractAddress(address(_config.systemConfigProxy));
        assertValidContractAddress(address(_config.proxyAdmin));
    }

    /// @notice Deploys and sets a new dispute game implementation
    /// @param _l2ChainId The L2 chain ID
    /// @param _disputeGame The current dispute game implementation
    /// @param _newDelayedWeth The new delayed WETH implementation
    /// @param _newAnchorStateRegistryProxy The new anchor state registry proxy
    /// @param _gameType The type of game to deploy
    /// @param _opChainConfig The OP chain configuration
    function deployAndSetNewGameImpl(
        uint256 _l2ChainId,
        IDisputeGame _disputeGame,
        IDelayedWETH _newDelayedWeth,
        IAnchorStateRegistry _newAnchorStateRegistryProxy,
        GameType _gameType,
        OPContractsManager.OpChainConfig memory _opChainConfig
    )
        internal
    {
        OPContractsManager.Blueprints memory bps = getBlueprints();
        OPContractsManager.Implementations memory impls = getImplementations();

        // Get the constructor params for the game
        IFaultDisputeGame.GameConstructorParams memory params =
            getGameConstructorParams(IFaultDisputeGame(address(_disputeGame)));

        // Modify the params with the new vm values.
        params.weth = _newDelayedWeth;
        params.anchorStateRegistry = _newAnchorStateRegistryProxy;
        params.vm = IBigStepper(impls.mipsImpl);

        // If the prestate is set in the config, use it. If not set, we'll try to use the prestate
        // that already exists on the current dispute game.
        if (Claim.unwrap(_opChainConfig.absolutePrestate) != bytes32(0)) {
            params.absolutePrestate = _opChainConfig.absolutePrestate;
        }

        // As a sanity check, if the prestate is zero here, revert.
        if (params.absolutePrestate.raw() == bytes32(0)) {
            revert OPContractsManager.PrestateNotSet();
        }

        IDisputeGame newGame;
        if (GameType.unwrap(_gameType) == GameType.unwrap(GameTypes.PERMISSIONED_CANNON)) {
            address proposer = getProposer(IPermissionedDisputeGame(address(_disputeGame)));
            address challenger = getChallenger(IPermissionedDisputeGame(address(_disputeGame)));
            newGame = IDisputeGame(
                Blueprint.deployFrom(
                    bps.permissionedDisputeGame1,
                    bps.permissionedDisputeGame2,
                    computeSalt(
                        _l2ChainId, reusableSaltMixer(_opChainConfig.systemConfigProxy), "PermissionedDisputeGame"
                    ),
                    encodePermissionedFDGConstructor(params, proposer, challenger)
                )
            );
        } else {
            newGame = IDisputeGame(
                Blueprint.deployFrom(
                    bps.permissionlessDisputeGame1,
                    bps.permissionlessDisputeGame2,
                    computeSalt(
                        _l2ChainId, reusableSaltMixer(_opChainConfig.systemConfigProxy), "PermissionlessDisputeGame"
                    ),
                    encodePermissionlessFDGConstructor(params)
                )
            );
        }

        // Grab the DisputeGameFactory from the SystemConfig.
        IDisputeGameFactory dgf = IDisputeGameFactory(_opChainConfig.systemConfigProxy.disputeGameFactory());

        // Set the new implementation.
        setDGFImplementation(dgf, _gameType, IDisputeGame(newGame));
    }
}

contract OPContractsManagerDeployer is OPContractsManagerBase {
    /// @notice Emitted when a new OP Stack chain is deployed.
    /// @param l2ChainId Chain ID of the new chain.
    /// @param deployer Address that deployed the chain.
    /// @param deployOutput ABI-encoded output of the deployment.
    event Deployed(uint256 indexed l2ChainId, address indexed deployer, bytes deployOutput);

    constructor(OPContractsManagerContractsContainer _contractsContainer) OPContractsManagerBase(_contractsContainer) { }

    /// @notice Deploys a new OP Stack chain.
    /// @param _input The deploy input parameters for the deployment.
    /// @param _superchainConfig The superchain config for the chain.
    /// @param _deployer The address to emit as the deployer address.
    /// @return The deploy output values of the deployment.
    function deploy(
        OPContractsManager.DeployInput calldata _input,
        ISuperchainConfig _superchainConfig,
        address _deployer
    )
        external
        virtual
        returns (OPContractsManager.DeployOutput memory)
    {
        assertValidInputs(_input);
        OPContractsManager.DeployOutput memory output;
        OPContractsManager.Blueprints memory blueprint = getBlueprints();
        OPContractsManager.Implementations memory implementation = getImplementations();

        // -------- Deploy Chain Singletons --------

        // The AddressManager is used to store the implementation for the L1CrossDomainMessenger
        // due to it's usage of the legacy ResolvedDelegateProxy.
        output.addressManager = IAddressManager(
            Blueprint.deployFrom(
                blueprint.addressManager,
                computeSalt(_input.l2ChainId, _input.saltMixer, "AddressManager"),
                abi.encode()
            )
        );
        // The ProxyAdmin is the owner of all proxies for the chain. We temporarily set the owner to
        // this contract, and then transfer ownership to the specified owner at the end of deployment.
        output.opChainProxyAdmin = IProxyAdmin(
            Blueprint.deployFrom(
                blueprint.proxyAdmin,
                computeSalt(_input.l2ChainId, _input.saltMixer, "ProxyAdmin"),
                abi.encode(address(this))
            )
        );
        // Set the AddressManager on the ProxyAdmin.
        output.opChainProxyAdmin.setAddressManager(output.addressManager);
        // Transfer ownership of the AddressManager to the ProxyAdmin.
        transferOwnership(address(output.addressManager), address(output.opChainProxyAdmin));

        // -------- Deploy Proxy Contracts --------

        // Deploy ERC-1967 proxied contracts.
        output.l1ERC721BridgeProxy =
            IL1ERC721Bridge(deployProxy(_input.l2ChainId, output.opChainProxyAdmin, _input.saltMixer, "L1ERC721Bridge"));
        output.optimismPortalProxy = IOptimismPortal(
            payable(deployProxy(_input.l2ChainId, output.opChainProxyAdmin, _input.saltMixer, "OptimismPortal"))
        );
        output.ethLockboxProxy =
            IETHLockbox(deployProxy(_input.l2ChainId, output.opChainProxyAdmin, _input.saltMixer, "ETHLockbox"));
        output.systemConfigProxy =
            ISystemConfig(deployProxy(_input.l2ChainId, output.opChainProxyAdmin, _input.saltMixer, "SystemConfig"));
        output.optimismMintableERC20FactoryProxy = IOptimismMintableERC20Factory(
            deployProxy(_input.l2ChainId, output.opChainProxyAdmin, _input.saltMixer, "OptimismMintableERC20Factory")
        );
        output.disputeGameFactoryProxy = IDisputeGameFactory(
            deployProxy(_input.l2ChainId, output.opChainProxyAdmin, _input.saltMixer, "DisputeGameFactory")
        );
        output.anchorStateRegistryProxy = IAnchorStateRegistry(
            deployProxy(_input.l2ChainId, output.opChainProxyAdmin, _input.saltMixer, "AnchorStateRegistry")
        );

        // Deploy legacy proxied contracts.
        output.l1StandardBridgeProxy = IL1StandardBridge(
            payable(
                Blueprint.deployFrom(
                    blueprint.l1ChugSplashProxy,
                    computeSalt(_input.l2ChainId, _input.saltMixer, "L1StandardBridge"),
                    abi.encode(output.opChainProxyAdmin)
                )
            )
        );
        output.opChainProxyAdmin.setProxyType(address(output.l1StandardBridgeProxy), IProxyAdmin.ProxyType.CHUGSPLASH);
        string memory contractName = "OVM_L1CrossDomainMessenger";
        output.l1CrossDomainMessengerProxy = IL1CrossDomainMessenger(
            Blueprint.deployFrom(
                blueprint.resolvedDelegateProxy,
                computeSalt(_input.l2ChainId, _input.saltMixer, "L1CrossDomainMessenger"),
                abi.encode(output.addressManager, contractName)
            )
        );
        output.opChainProxyAdmin.setProxyType(
            address(output.l1CrossDomainMessengerProxy), IProxyAdmin.ProxyType.RESOLVED
        );
        output.opChainProxyAdmin.setImplementationName(address(output.l1CrossDomainMessengerProxy), contractName);

        // Eventually we will switch from DelayedWETHPermissionedGameProxy to DelayedWETHPermissionlessGameProxy.
        output.delayedWETHPermissionedGameProxy = IDelayedWETH(
            payable(
                deployProxy(_input.l2ChainId, output.opChainProxyAdmin, _input.saltMixer, "DelayedWETHPermissionedGame")
            )
        );

        // While not a proxy, we deploy the PermissionedDisputeGame here as well because it's bespoke per chain.
        output.permissionedDisputeGame = IPermissionedDisputeGame(
            Blueprint.deployFrom(
                blueprint.permissionedDisputeGame1,
                blueprint.permissionedDisputeGame2,
                computeSalt(_input.l2ChainId, _input.saltMixer, "PermissionedDisputeGame"),
                encodePermissionedFDGConstructor(
                    IFaultDisputeGame.GameConstructorParams({
                        gameType: GameTypes.PERMISSIONED_CANNON,
                        absolutePrestate: _input.disputeAbsolutePrestate,
                        maxGameDepth: _input.disputeMaxGameDepth,
                        splitDepth: _input.disputeSplitDepth,
                        clockExtension: _input.disputeClockExtension,
                        maxClockDuration: _input.disputeMaxClockDuration,
                        vm: IBigStepper(implementation.mipsImpl),
                        weth: IDelayedWETH(payable(address(output.delayedWETHPermissionedGameProxy))),
                        anchorStateRegistry: IAnchorStateRegistry(address(output.anchorStateRegistryProxy)),
                        l2ChainId: _input.l2ChainId
                    }),
                    _input.roles.proposer,
                    _input.roles.challenger
                )
            )
        );

        // -------- Set and Initialize Proxy Implementations --------
        bytes memory data;

        data = encodeL1ERC721BridgeInitializer(output);
        upgradeToAndCall(
            output.opChainProxyAdmin, address(output.l1ERC721BridgeProxy), implementation.l1ERC721BridgeImpl, data
        );

        // Initialize the SystemConfig before the ETHLockbox, required because the ETHLockbox will
        // try to get the SuperchainConfig from the SystemConfig inside of its initializer. Also
        // need to initialize before OptimismPortal because OptimismPortal does some sanity checks
        // based on the ETHLockbox feature flag.
        data = encodeSystemConfigInitializer(_input, output, _superchainConfig);
        upgradeToAndCall(
            output.opChainProxyAdmin, address(output.systemConfigProxy), implementation.systemConfigImpl, data
        );

        // If the interop feature was requested, enable the ETHLockbox feature in the SystemConfig
        // contract. Only other way to get the ETHLockbox feature as of u16a is to have already had
        // the ETHLockbox in U16 and then upgrade to U16a.
        if (isDevFeatureEnabled(DevFeatures.OPTIMISM_PORTAL_INTEROP)) {
            output.systemConfigProxy.setFeature(Features.ETH_LOCKBOX, true);
        }

        // Initialize the OptimismPortal.
        if (isDevFeatureEnabled(DevFeatures.OPTIMISM_PORTAL_INTEROP)) {
            data = encodeOptimismPortalInteropInitializer(output);
            upgradeToAndCall(
                output.opChainProxyAdmin,
                address(output.optimismPortalProxy),
                implementation.optimismPortalInteropImpl,
                data
            );
        } else {
            data = encodeOptimismPortalInitializer(output);
            upgradeToAndCall(
                output.opChainProxyAdmin, address(output.optimismPortalProxy), implementation.optimismPortalImpl, data
            );
        }

        // Initialize the ETHLockbox.
        IOptimismPortal[] memory portals = new IOptimismPortal[](1);
        portals[0] = output.optimismPortalProxy;
        data = encodeETHLockboxInitializer(output, portals);
        upgradeToAndCall(output.opChainProxyAdmin, address(output.ethLockboxProxy), implementation.ethLockboxImpl, data);

        data = encodeOptimismMintableERC20FactoryInitializer(output);
        upgradeToAndCall(
            output.opChainProxyAdmin,
            address(output.optimismMintableERC20FactoryProxy),
            implementation.optimismMintableERC20FactoryImpl,
            data
        );

        data = encodeL1CrossDomainMessengerInitializer(output);
        upgradeToAndCall(
            output.opChainProxyAdmin,
            address(output.l1CrossDomainMessengerProxy),
            implementation.l1CrossDomainMessengerImpl,
            data
        );

        data = encodeL1StandardBridgeInitializer(output);
        upgradeToAndCall(
            output.opChainProxyAdmin, address(output.l1StandardBridgeProxy), implementation.l1StandardBridgeImpl, data
        );

        // Eventually we will switch from DelayedWETHPermissionedGameProxy to DelayedWETHPermissionlessGameProxy.
        data = encodeDelayedWETHInitializer(output);
        upgradeToAndCall(
            output.opChainProxyAdmin,
            address(output.delayedWETHPermissionedGameProxy),
            implementation.delayedWETHImpl,
            data
        );

        // We set the initial owner to this contract, set game implementations, then transfer ownership.
        data = encodeDisputeGameFactoryInitializer();
        upgradeToAndCall(
            output.opChainProxyAdmin,
            address(output.disputeGameFactoryProxy),
            implementation.disputeGameFactoryImpl,
            data
        );
        setDGFImplementation(
            output.disputeGameFactoryProxy,
            GameTypes.PERMISSIONED_CANNON,
            IDisputeGame(address(output.permissionedDisputeGame))
        );

        transferOwnership(address(output.disputeGameFactoryProxy), address(_input.roles.opChainProxyAdminOwner));

        data = encodeAnchorStateRegistryInitializer(_input, output);
        upgradeToAndCall(
            output.opChainProxyAdmin,
            address(output.anchorStateRegistryProxy),
            implementation.anchorStateRegistryImpl,
            data
        );

        // -------- Finalize Deployment --------
        // Transfer ownership of the ProxyAdmin from this contract to the specified owner.
        transferOwnership(address(output.opChainProxyAdmin), _input.roles.opChainProxyAdminOwner);

        emit Deployed(_input.l2ChainId, _deployer, abi.encode(output));
        return output;
    }

    /// @notice Returns default, standard config arguments for the SystemConfig initializer.
    /// This is used by subclasses to reduce code duplication.
    function defaultSystemConfigParams(
        OPContractsManager.DeployInput memory, /* _input */
        OPContractsManager.DeployOutput memory _output
    )
        internal
        view
        virtual
        returns (IResourceMetering.ResourceConfig memory resourceConfig_, ISystemConfig.Addresses memory opChainAddrs_)
    {
        resourceConfig_ = Constants.DEFAULT_RESOURCE_CONFIG();

        opChainAddrs_ = ISystemConfig.Addresses({
            l1CrossDomainMessenger: address(_output.l1CrossDomainMessengerProxy),
            l1ERC721Bridge: address(_output.l1ERC721BridgeProxy),
            l1StandardBridge: address(_output.l1StandardBridgeProxy),
            optimismPortal: address(_output.optimismPortalProxy),
            optimismMintableERC20Factory: address(_output.optimismMintableERC20FactoryProxy)
        });

        assertValidContractAddress(opChainAddrs_.l1CrossDomainMessenger);
        assertValidContractAddress(opChainAddrs_.l1ERC721Bridge);
        assertValidContractAddress(opChainAddrs_.l1StandardBridge);
        assertValidContractAddress(opChainAddrs_.optimismPortal);
        assertValidContractAddress(opChainAddrs_.optimismMintableERC20Factory);
    }

    // -------- Utilities --------

    /// @notice Verifies that all inputs are valid and reverts if any are invalid.
    /// Typically the proxy admin owner is expected to have code, but this is not enforced here.
    function assertValidInputs(OPContractsManager.DeployInput calldata _input) internal view {
        if (_input.l2ChainId == 0 || _input.l2ChainId == block.chainid) revert OPContractsManager.InvalidChainId();

        if (_input.roles.opChainProxyAdminOwner == address(0)) {
            revert OPContractsManager.InvalidRoleAddress("opChainProxyAdminOwner");
        }
        if (_input.roles.systemConfigOwner == address(0)) {
            revert OPContractsManager.InvalidRoleAddress("systemConfigOwner");
        }
        if (_input.roles.batcher == address(0)) revert OPContractsManager.InvalidRoleAddress("batcher");
        if (_input.roles.unsafeBlockSigner == address(0)) {
            revert OPContractsManager.InvalidRoleAddress("unsafeBlockSigner");
        }
        if (_input.roles.proposer == address(0)) revert OPContractsManager.InvalidRoleAddress("proposer");
        if (_input.roles.challenger == address(0)) revert OPContractsManager.InvalidRoleAddress("challenger");

        if (_input.startingAnchorRoot.length == 0) revert OPContractsManager.InvalidStartingAnchorRoot();
        if (bytes32(_input.startingAnchorRoot) == bytes32(0)) revert OPContractsManager.InvalidStartingAnchorRoot();
    }

    /// @notice Transfers ownership
    function transferOwnership(address _target, address _newOwner) internal {
        // All transferOwnership targets have the same selector, so we just use IAddressManager
        IAddressManager(_target).transferOwnership(_newOwner);
    }

    // -------- Initializer Encoding --------

    /// @notice Helper method for encoding the L1ERC721Bridge initializer data.
    function encodeL1ERC721BridgeInitializer(OPContractsManager.DeployOutput memory _output)
        internal
        view
        virtual
        returns (bytes memory)
    {
        return
            abi.encodeCall(IL1ERC721Bridge.initialize, (_output.l1CrossDomainMessengerProxy, _output.systemConfigProxy));
    }

    /// @notice Helper method for encoding the OptimismPortal initializer data.
    function encodeOptimismPortalInitializer(OPContractsManager.DeployOutput memory _output)
        internal
        view
        virtual
        returns (bytes memory)
    {
        return abi.encodeCall(IOptimismPortal.initialize, (_output.systemConfigProxy, _output.anchorStateRegistryProxy));
    }

    /// @notice Helper method for encoding the OptimismPortalInterop initializer data.
    function encodeOptimismPortalInteropInitializer(OPContractsManager.DeployOutput memory _output)
        internal
        view
        virtual
        returns (bytes memory)
    {
        return abi.encodeCall(
            IOptimismPortalInterop.initialize,
            (_output.systemConfigProxy, _output.anchorStateRegistryProxy, _output.ethLockboxProxy)
        );
    }

    /// @notice Helper method for encoding the ETHLockbox initializer data.
    function encodeETHLockboxInitializer(
        OPContractsManager.DeployOutput memory _output,
        IOptimismPortal[] memory _portals
    )
        internal
        view
        virtual
        returns (bytes memory)
    {
        return abi.encodeCall(IETHLockbox.initialize, (_output.systemConfigProxy, _portals));
    }

    /// @notice Helper method for encoding the SystemConfig initializer data.
    function encodeSystemConfigInitializer(
        OPContractsManager.DeployInput memory _input,
        OPContractsManager.DeployOutput memory _output,
        ISuperchainConfig _superchainConfig
    )
        internal
        view
        virtual
        returns (bytes memory)
    {
        (IResourceMetering.ResourceConfig memory referenceResourceConfig, ISystemConfig.Addresses memory opChainAddrs) =
            defaultSystemConfigParams(_input, _output);

        return abi.encodeCall(
            ISystemConfig.initialize,
            (
                _input.roles.systemConfigOwner,
                _input.basefeeScalar,
                _input.blobBasefeeScalar,
                bytes32(uint256(uint160(_input.roles.batcher))), // batcherHash
                _input.gasLimit,
                _input.roles.unsafeBlockSigner,
                referenceResourceConfig,
                chainIdToBatchInboxAddress(_input.l2ChainId),
                opChainAddrs,
                _input.l2ChainId,
                _superchainConfig
            )
        );
    }

    /// @notice Helper method for encoding the OptimismMintableERC20Factory initializer data.
    function encodeOptimismMintableERC20FactoryInitializer(OPContractsManager.DeployOutput memory _output)
        internal
        pure
        virtual
        returns (bytes memory)
    {
        return abi.encodeCall(IOptimismMintableERC20Factory.initialize, (address(_output.l1StandardBridgeProxy)));
    }

    /// @notice Helper method for encoding the L1CrossDomainMessenger initializer data.
    function encodeL1CrossDomainMessengerInitializer(OPContractsManager.DeployOutput memory _output)
        internal
        view
        virtual
        returns (bytes memory)
    {
        return
            abi.encodeCall(IL1CrossDomainMessenger.initialize, (_output.systemConfigProxy, _output.optimismPortalProxy));
    }

    /// @notice Helper method for encoding the L1StandardBridge initializer data.
    function encodeL1StandardBridgeInitializer(OPContractsManager.DeployOutput memory _output)
        internal
        view
        virtual
        returns (bytes memory)
    {
        return abi.encodeCall(
            IL1StandardBridge.initialize, (_output.l1CrossDomainMessengerProxy, _output.systemConfigProxy)
        );
    }

    function encodeDisputeGameFactoryInitializer() internal view virtual returns (bytes memory) {
        // This contract must be the initial owner so we can set game implementations, then
        // ownership is transferred after.
        return abi.encodeCall(IDisputeGameFactory.initialize, (address(this)));
    }

    function encodeAnchorStateRegistryInitializer(
        OPContractsManager.DeployInput memory _input,
        OPContractsManager.DeployOutput memory _output
    )
        internal
        view
        virtual
        returns (bytes memory)
    {
        Proposal memory startingAnchorRoot = abi.decode(_input.startingAnchorRoot, (Proposal));
        return abi.encodeCall(
            IAnchorStateRegistry.initialize,
            (
                _output.systemConfigProxy,
                _output.disputeGameFactoryProxy,
                startingAnchorRoot,
                GameTypes.PERMISSIONED_CANNON
            )
        );
    }

    function encodeDelayedWETHInitializer(OPContractsManager.DeployOutput memory _output)
        internal
        view
        virtual
        returns (bytes memory)
    {
        return abi.encodeCall(IDelayedWETH.initialize, (_output.systemConfigProxy));
    }
}

/// @title OPContractsManagerInteropMigrator
/// @notice This contract is used to migrate one or more OP Stack chains to use the Super Root dispute
///         games and shared dispute game contracts.
contract OPContractsManagerInteropMigrator is OPContractsManagerBase {
    /// @notice Thrown when the ProxyAdmin owner of one or more of the provided OP Stack chains
    ///         being migrated does not match the ProxyAdmin owner of the first provided chain.
    error OPContractsManagerInteropMigrator_ProxyAdminOwnerMismatch();

    /// @notice Thrown when the SuperchainConfig of one or more of the provided OP Stack chains
    ///         being migrated does not match the SuperchainConfig of the first provided chain.
    error OPContractsManagerInteropMigrator_SuperchainConfigMismatch();

    /// @notice Thrown when the absolute prestate of one or more of the provided OP Stack chains
    ///         being migrated does not match the absolute prestate of the first provided chain.
    error OPContractsManagerInteropMigrator_AbsolutePrestateMismatch();

    /// @notice Parameters for creating the new Super Root dispute games that must be provided by
    ///         the caller. Other parameters are selected automatically.
    struct GameParameters {
        address proposer;
        address challenger;
        uint256 maxGameDepth;
        uint256 splitDepth;
        uint256 initBond;
        Duration clockExtension;
        Duration maxClockDuration;
    }

    /// @notice Input parameters for the migration.
    struct MigrateInput {
        bool usePermissionlessGame;
        Proposal startingAnchorRoot;
        GameParameters gameParameters;
        OPContractsManager.OpChainConfig[] opChainConfigs;
    }

    /// @param _contractsContainer Container of blueprints and implementations.
    constructor(OPContractsManagerContractsContainer _contractsContainer) OPContractsManagerBase(_contractsContainer) { }

    /// @notice Migrates one or more OP Stack chains to use the Super Root dispute games and shared
    ///         dispute game contracts.
    /// @dev WARNING: This is a one-way operation. You cannot easily undo this operation without a
    ///      smart contract upgrade. Do not call this function unless you are 100% confident that
    ///      you know what you're doing and that you are prepared to fully execute this migration.
    /// @param _input The input parameters for the migration.
    function migrate(MigrateInput calldata _input) public virtual {
        // Check that all of the configs have the same proxy admin owner and prestate.
        for (uint256 i = 0; i < _input.opChainConfigs.length; i++) {
            // Different chains might actually have different ProxyAdmin contracts, but it's fine
            // as long as the owner of all of those contracts is the same.
            if (_input.opChainConfigs[i].proxyAdmin.owner() != _input.opChainConfigs[0].proxyAdmin.owner()) {
                revert OPContractsManagerInteropMigrator_ProxyAdminOwnerMismatch();
            }
            if (_input.opChainConfigs[i].absolutePrestate.raw() != _input.opChainConfigs[0].absolutePrestate.raw()) {
                revert OPContractsManagerInteropMigrator_AbsolutePrestateMismatch();
            }
        }

        // Grab an array of portals from the configs.
        IOptimismPortalInterop[] memory portals = new IOptimismPortalInterop[](_input.opChainConfigs.length);
        for (uint256 i = 0; i < _input.opChainConfigs.length; i++) {
            portals[i] = IOptimismPortalInterop(payable(_input.opChainConfigs[i].systemConfigProxy.optimismPortal()));
        }

        // Check that the portals have the same SuperchainConfig.
        for (uint256 i = 0; i < portals.length; i++) {
            if (portals[i].superchainConfig() != portals[0].superchainConfig()) {
                revert OPContractsManagerInteropMigrator_SuperchainConfigMismatch();
            }
        }

        // NOTE that here and in the rest of this function, we are using the first provided chain's
        // ProxyAdmin contract as the ProxyAdmin for all of the newly shared contracts. This is
        // safe because we already checked that all of the provided chains have the same ProxyAdmin
        // owner and therefore have the same access models.
        address proxyAdminOwner = _input.opChainConfigs[0].proxyAdmin.owner();

        // Deploy the new ETHLockbox.
        // NOTE that here and in the rest of this function we use block.timestamp as a fake chain
        // id for any new contracts that are deployed. The L2 chain id is not used for anything
        // except the salt mixer, so making it the same as the block timestamp means that new
        // contracts will be generated every time this function is called. This is totally fine for
        // our purposes here, there's no strong need to have deterministic addresses ahead of time.
        IETHLockbox newEthLockbox = IETHLockbox(
            deployProxy({
                _l2ChainId: block.timestamp,
                _proxyAdmin: _input.opChainConfigs[0].proxyAdmin,
                _saltMixer: reusableSaltMixer(_input.opChainConfigs[0].systemConfigProxy),
                _contractName: "ETHLockbox-Interop"
            })
        );

        // Separate context to avoid stack too deep.
        {
            // Lockbox requires standard portal interfaces, need to cast to IOptimismPortal.
            IOptimismPortal[] memory castedPortals;
            assembly ("memory-safe") {
                castedPortals := portals
            }

            // Initialize the new ETHLockbox.
            // Note that this authorizes the portals to use the ETHLockbox.
            upgradeToAndCall(
                _input.opChainConfigs[0].proxyAdmin,
                address(newEthLockbox),
                getImplementations().ethLockboxImpl,
                abi.encodeCall(IETHLockbox.initialize, (portals[0].systemConfig(), castedPortals))
            );
        }

        // Deploy the new DisputeGameFactory.
        IDisputeGameFactory newDisputeGameFactory = IDisputeGameFactory(
            deployProxy({
                _l2ChainId: block.timestamp,
                _proxyAdmin: _input.opChainConfigs[0].proxyAdmin,
                _saltMixer: reusableSaltMixer(_input.opChainConfigs[0].systemConfigProxy),
                _contractName: "DisputeGameFactory-Interop"
            })
        );

        // Initialize the new DisputeGameFactory.
        upgradeToAndCall(
            _input.opChainConfigs[0].proxyAdmin,
            address(newDisputeGameFactory),
            getImplementations().disputeGameFactoryImpl,
            abi.encodeCall(IDisputeGameFactory.initialize, (proxyAdminOwner))
        );

        // Deploy the new AnchorStateRegistry.
        IAnchorStateRegistry newAnchorStateRegistry = IAnchorStateRegistry(
            deployProxy({
                _l2ChainId: block.timestamp,
                _proxyAdmin: _input.opChainConfigs[0].proxyAdmin,
                _saltMixer: reusableSaltMixer(_input.opChainConfigs[0].systemConfigProxy),
                _contractName: "AnchorStateRegistry-Interop"
            })
        );

        // Select the correct game type based on the input.
        GameType newGameType;
        if (_input.usePermissionlessGame) {
            newGameType = GameTypes.SUPER_CANNON;
        } else {
            newGameType = GameTypes.SUPER_PERMISSIONED_CANNON;
        }

        // We can use portals[0].systemConfig() as they are members of the same superchain cluster (shared lockbox)
        // Initialize the new AnchorStateRegistry.
        upgradeToAndCall(
            _input.opChainConfigs[0].proxyAdmin,
            address(newAnchorStateRegistry),
            getImplementations().anchorStateRegistryImpl,
            abi.encodeCall(
                IAnchorStateRegistry.initialize,
                (portals[0].systemConfig(), newDisputeGameFactory, _input.startingAnchorRoot, newGameType)
            )
        );

        // Migrate each portal to the new ETHLockbox and AnchorStateRegistry.
        for (uint256 i = 0; i < portals.length; i++) {
            // Authorize the existing ETHLockboxes to use the new ETHLockbox.
            IETHLockbox existingLockbox = IETHLockbox(payable(address(portals[i].ethLockbox())));
            newEthLockbox.authorizeLockbox(existingLockbox);

            // Migrate the existing ETHLockbox to the new ETHLockbox.
            existingLockbox.migrateLiquidity(newEthLockbox);

            // Before migrating the portal, clear out any implementations that might exist in the
            // old DisputeGameFactory proxy. We clear out all 4 potential game types to be safe.
            IDisputeGameFactory oldDisputeGameFactory =
                IDisputeGameFactory(payable(address(portals[i].disputeGameFactory())));
            oldDisputeGameFactory.setImplementation(GameTypes.CANNON, IDisputeGame(address(0)));
            oldDisputeGameFactory.setImplementation(GameTypes.SUPER_CANNON, IDisputeGame(address(0)));
            oldDisputeGameFactory.setImplementation(GameTypes.PERMISSIONED_CANNON, IDisputeGame(address(0)));
            oldDisputeGameFactory.setImplementation(GameTypes.SUPER_PERMISSIONED_CANNON, IDisputeGame(address(0)));
            if (isDevFeatureEnabled(DevFeatures.CANNON_KONA)) {
                oldDisputeGameFactory.setImplementation(GameTypes.CANNON_KONA, IDisputeGame(address(0)));
                oldDisputeGameFactory.setImplementation(GameTypes.SUPER_CANNON_KONA, IDisputeGame(address(0)));
            }

            // Migrate the portal to the new ETHLockbox and AnchorStateRegistry.
            portals[i].migrateToSuperRoots(newEthLockbox, newAnchorStateRegistry);
        }

        // Separate context to avoid stack too deep.
        {
            // Deploy a new DelayedWETH proxy for the permissioned game.
            IDelayedWETH newPermissionedDelayedWETHProxy = IDelayedWETH(
                payable(
                    deployProxy({
                        _l2ChainId: block.timestamp,
                        _proxyAdmin: _input.opChainConfigs[0].proxyAdmin,
                        _saltMixer: reusableSaltMixer(_input.opChainConfigs[0].systemConfigProxy),
                        _contractName: "DelayedWETH-Interop-Permissioned"
                    })
                )
            );

            // Initialize the new DelayedWETH proxy.
            upgradeToAndCall(
                _input.opChainConfigs[0].proxyAdmin,
                address(newPermissionedDelayedWETHProxy),
                getImplementations().delayedWETHImpl,
                abi.encodeCall(IDelayedWETH.initialize, (portals[0].systemConfig()))
            );

            // Deploy the new SuperPermissionedDisputeGame.
            // NOTE that we use a chain id of 0 here (instead of the block timestamp) because the
            // use of the chain id is different and actually passed into the constructor of the
            // dispute game contracts. Since these are Super dispute games and involve multiple
            // chains, the contracts enforce that the chain id is zero.
            ISuperPermissionedDisputeGame newSuperPDG = ISuperPermissionedDisputeGame(
                Blueprint.deployFrom(
                    blueprints().superPermissionedDisputeGame1,
                    blueprints().superPermissionedDisputeGame2,
                    computeSalt(
                        block.timestamp,
                        reusableSaltMixer(_input.opChainConfigs[0].systemConfigProxy),
                        "SuperPermissionedDisputeGame"
                    ),
                    encodePermissionedSuperFDGConstructor(
                        ISuperFaultDisputeGame.GameConstructorParams({
                            gameType: GameTypes.SUPER_PERMISSIONED_CANNON,
                            absolutePrestate: _input.opChainConfigs[0].absolutePrestate,
                            maxGameDepth: _input.gameParameters.maxGameDepth,
                            splitDepth: _input.gameParameters.splitDepth,
                            clockExtension: _input.gameParameters.clockExtension,
                            maxClockDuration: _input.gameParameters.maxClockDuration,
                            vm: IBigStepper(getImplementations().mipsImpl),
                            weth: newPermissionedDelayedWETHProxy,
                            anchorStateRegistry: newAnchorStateRegistry,
                            l2ChainId: 0
                        }),
                        _input.gameParameters.proposer,
                        _input.gameParameters.challenger
                    )
                )
            );

            // Register the new SuperPermissionedDisputeGame.
            newDisputeGameFactory.setImplementation(
                GameTypes.SUPER_PERMISSIONED_CANNON, IDisputeGame(address(newSuperPDG))
            );
            newDisputeGameFactory.setInitBond(GameTypes.SUPER_PERMISSIONED_CANNON, _input.gameParameters.initBond);
        }

        // If the permissionless game is being used, set that up too.
        if (_input.usePermissionlessGame) {
            // Deploy a new DelayedWETH proxy for the permissionless game.
            IDelayedWETH newPermissionlessDelayedWETHProxy = IDelayedWETH(
                payable(
                    deployProxy({
                        _l2ChainId: block.timestamp,
                        _proxyAdmin: _input.opChainConfigs[0].proxyAdmin,
                        _saltMixer: reusableSaltMixer(_input.opChainConfigs[0].systemConfigProxy),
                        _contractName: "DelayedWETH-Interop-Permissionless"
                    })
                )
            );

            // Initialize the new DelayedWETH proxy.
            upgradeToAndCall(
                _input.opChainConfigs[0].proxyAdmin,
                address(newPermissionlessDelayedWETHProxy),
                getImplementations().delayedWETHImpl,
                abi.encodeCall(IDelayedWETH.initialize, (portals[0].systemConfig()))
            );

            // Deploy the new SuperFaultDisputeGame.
            ISuperFaultDisputeGame newSuperFDG = ISuperFaultDisputeGame(
                Blueprint.deployFrom(
                    blueprints().superPermissionlessDisputeGame1,
                    blueprints().superPermissionlessDisputeGame2,
                    computeSalt(
                        block.timestamp,
                        reusableSaltMixer(_input.opChainConfigs[0].systemConfigProxy),
                        "SuperFaultDisputeGame"
                    ),
                    encodePermissionlessSuperFDGConstructor(
                        ISuperFaultDisputeGame.GameConstructorParams({
                            gameType: GameTypes.SUPER_CANNON,
                            absolutePrestate: _input.opChainConfigs[0].absolutePrestate,
                            maxGameDepth: _input.gameParameters.maxGameDepth,
                            splitDepth: _input.gameParameters.splitDepth,
                            clockExtension: _input.gameParameters.clockExtension,
                            maxClockDuration: _input.gameParameters.maxClockDuration,
                            vm: IBigStepper(getImplementations().mipsImpl),
                            weth: newPermissionlessDelayedWETHProxy,
                            anchorStateRegistry: newAnchorStateRegistry,
                            l2ChainId: 0
                        })
                    )
                )
            );

            // Register the new SuperFaultDisputeGame.
            newDisputeGameFactory.setImplementation(GameTypes.SUPER_CANNON, IDisputeGame(address(newSuperFDG)));
            newDisputeGameFactory.setInitBond(GameTypes.SUPER_CANNON, _input.gameParameters.initBond);
        }
    }
}

contract OPContractsManager is ISemver {
    // -------- Structs --------

    /// @notice Represents the roles that can be set when deploying a standard OP Stack chain.
    struct Roles {
        address opChainProxyAdminOwner;
        address systemConfigOwner;
        address batcher;
        address unsafeBlockSigner;
        address proposer;
        address challenger;
    }

    /// @notice The full set of inputs to deploy a new OP Stack chain.
    struct DeployInput {
        Roles roles;
        uint32 basefeeScalar;
        uint32 blobBasefeeScalar;
        uint256 l2ChainId;
        // The correct type is Proposal memory but OP Deployer does not yet support structs.
        bytes startingAnchorRoot;
        // The salt mixer is used as part of making the resulting salt unique.
        string saltMixer;
        uint64 gasLimit;
        // Configurable dispute game parameters.
        GameType disputeGameType;
        Claim disputeAbsolutePrestate;
        uint256 disputeMaxGameDepth;
        uint256 disputeSplitDepth;
        Duration disputeClockExtension;
        Duration disputeMaxClockDuration;
    }

    /// @notice The full set of outputs from deploying a new OP Stack chain.
    struct DeployOutput {
        IProxyAdmin opChainProxyAdmin;
        IAddressManager addressManager;
        IL1ERC721Bridge l1ERC721BridgeProxy;
        ISystemConfig systemConfigProxy;
        IOptimismMintableERC20Factory optimismMintableERC20FactoryProxy;
        IL1StandardBridge l1StandardBridgeProxy;
        IL1CrossDomainMessenger l1CrossDomainMessengerProxy;
        IETHLockbox ethLockboxProxy;
        // Fault proof contracts below.
        IOptimismPortal optimismPortalProxy;
        IDisputeGameFactory disputeGameFactoryProxy;
        IAnchorStateRegistry anchorStateRegistryProxy;
        IFaultDisputeGame faultDisputeGame;
        IPermissionedDisputeGame permissionedDisputeGame;
        IDelayedWETH delayedWETHPermissionedGameProxy;
        IDelayedWETH delayedWETHPermissionlessGameProxy;
    }

    /// @notice Addresses of ERC-5202 Blueprint contracts. There are used for deploying full size
    /// contracts, to reduce the code size of this factory contract. If it deployed full contracts
    /// using the `new Proxy()` syntax, the code size would get large fast, since this contract would
    /// contain the bytecode of every contract it deploys. Therefore we instead use Blueprints to
    /// reduce the code size of this contract.
    struct Blueprints {
        address addressManager;
        address proxy;
        address proxyAdmin;
        address l1ChugSplashProxy;
        address resolvedDelegateProxy;
        address permissionedDisputeGame1;
        address permissionedDisputeGame2;
        address permissionlessDisputeGame1;
        address permissionlessDisputeGame2;
        address superPermissionedDisputeGame1;
        address superPermissionedDisputeGame2;
        address superPermissionlessDisputeGame1;
        address superPermissionlessDisputeGame2;
    }

    /// @notice The latest implementation contracts for the OP Stack.
    struct Implementations {
        address superchainConfigImpl;
        address protocolVersionsImpl;
        address l1ERC721BridgeImpl;
        address optimismPortalImpl;
        address optimismPortalInteropImpl;
        address ethLockboxImpl;
        address systemConfigImpl;
        address optimismMintableERC20FactoryImpl;
        address l1CrossDomainMessengerImpl;
        address l1StandardBridgeImpl;
        address disputeGameFactoryImpl;
        address anchorStateRegistryImpl;
        address delayedWETHImpl;
        address mipsImpl;
    }

    /// @notice The input required to identify a chain for upgrading, along with new prestate hashes
    struct OpChainConfig {
        ISystemConfig systemConfigProxy;
        IProxyAdmin proxyAdmin;
        Claim absolutePrestate;
    }

    /// @notice The input required to identify a chain for updating prestates
    struct UpdatePrestateInput {
        ISystemConfig systemConfigProxy;
        Claim cannonPrestate;
        Claim cannonKonaPrestate;
    }

    struct AddGameInput {
        string saltMixer;
        ISystemConfig systemConfig;
        IProxyAdmin proxyAdmin;
        IDelayedWETH delayedWETH;
        GameType disputeGameType;
        Claim disputeAbsolutePrestate;
        uint256 disputeMaxGameDepth;
        uint256 disputeSplitDepth;
        Duration disputeClockExtension;
        Duration disputeMaxClockDuration;
        uint256 initialBond;
        IBigStepper vm;
        bool permissioned;
    }

    struct AddGameOutput {
        IDelayedWETH delayedWETH;
        IFaultDisputeGame faultDisputeGame;
    }

    // -------- Constants and Variables --------

    /// @custom:semver 4.0.0
    function version() public pure virtual returns (string memory) {
        return "4.0.0";
    }

    OPContractsManagerGameTypeAdder public immutable opcmGameTypeAdder;

    OPContractsManagerDeployer public immutable opcmDeployer;

    OPContractsManagerUpgrader public immutable opcmUpgrader;

    OPContractsManagerInteropMigrator public immutable opcmInteropMigrator;

    OPContractsManagerStandardValidator public immutable opcmStandardValidator;

    /// @notice Address of the SuperchainConfig contract shared by all chains.
    ISuperchainConfig public immutable superchainConfig;

    /// @notice Address of the ProtocolVersions contract shared by all chains.
    IProtocolVersions public immutable protocolVersions;

    /// @notice Address of the SuperchainProxyAdmin contract shared by all chains.
    IProxyAdmin public immutable superchainProxyAdmin;

    /// @notice The OPContractsManager contract that is currently being used. This is needed in the upgrade function
    /// which is intended to be DELEGATECALLed.
    OPContractsManager internal immutable thisOPCM;

    // -------- Errors --------

    /// @notice Thrown when an address is the zero address.
    error AddressNotFound(address who);

    /// @notice Throw when a contract address has no code.
    error AddressHasNoCode(address who);

    /// @notice Thrown when a release version is already set.
    error AlreadyReleased();

    /// @notice Thrown when an invalid `l2ChainId` is provided to `deploy`.
    error InvalidChainId();

    /// @notice Thrown when a role's address is not valid.
    error InvalidRoleAddress(string role);

    /// @notice Thrown when the latest release is not set upon initialization.
    error LatestReleaseNotSet();

    /// @notice Thrown when the starting anchor root is not provided.
    error InvalidStartingAnchorRoot();

    /// @notice Thrown when certain methods are called outside of a DELEGATECALL.
    error OnlyDelegatecall();

    /// @notice Thrown when game configs passed to addGameType are invalid.
    error InvalidGameConfigs();

    /// @notice Thrown when the SuperchainConfig of the chain does not match the SuperchainConfig of this OPCM.
    error SuperchainConfigMismatch(ISystemConfig systemConfig);

    /// @notice Thrown when the SuperchainProxyAdmin does not match the SuperchainConfig's admin.
    error SuperchainProxyAdminMismatch();

    /// @notice Thrown when a prestate is not set for a game.
    error PrestateNotSet();

    /// @notice Thrown when the prestate of a permissioned disputed game is 0.
    error PrestateRequired();

    // -------- Methods --------

    constructor(
        OPContractsManagerGameTypeAdder _opcmGameTypeAdder,
        OPContractsManagerDeployer _opcmDeployer,
        OPContractsManagerUpgrader _opcmUpgrader,
        OPContractsManagerInteropMigrator _opcmInteropMigrator,
        OPContractsManagerStandardValidator _opcmStandardValidator,
        ISuperchainConfig _superchainConfig,
        IProtocolVersions _protocolVersions,
        IProxyAdmin _superchainProxyAdmin
    ) {
        _opcmDeployer.assertValidContractAddress(address(_superchainConfig));
        _opcmDeployer.assertValidContractAddress(address(_protocolVersions));
        _opcmDeployer.assertValidContractAddress(address(_opcmGameTypeAdder));
        _opcmDeployer.assertValidContractAddress(address(_opcmDeployer));
        _opcmDeployer.assertValidContractAddress(address(_opcmUpgrader));
        _opcmDeployer.assertValidContractAddress(address(_opcmInteropMigrator));
        _opcmDeployer.assertValidContractAddress(address(_opcmStandardValidator));
        opcmGameTypeAdder = _opcmGameTypeAdder;
        opcmDeployer = _opcmDeployer;
        opcmUpgrader = _opcmUpgrader;
        opcmInteropMigrator = _opcmInteropMigrator;
        opcmStandardValidator = _opcmStandardValidator;
        superchainConfig = _superchainConfig;
        protocolVersions = _protocolVersions;
        superchainProxyAdmin = _superchainProxyAdmin;
        thisOPCM = this;
    }

    /// @notice Validates the configuration of the L1 contracts.
    function validate(
        OPContractsManagerStandardValidator.ValidationInput memory _input,
        bool _allowFailure
    )
        public
        view
        returns (string memory)
    {
        return opcmStandardValidator.validate(_input, _allowFailure);
    }

    /// @notice Validates the configuration of the L1 contracts.
    /// @notice Supports overrides of certain storage values denoted in the ValidationOverrides struct.
    function validateWithOverrides(
        OPContractsManagerStandardValidator.ValidationInput memory _input,
        bool _allowFailure,
        OPContractsManagerStandardValidator.ValidationOverrides memory _overrides
    )
        public
        view
        returns (string memory)
    {
        return opcmStandardValidator.validateWithOverrides(_input, _allowFailure, _overrides);
    }

    /// @notice Deploys a new OP Stack chain.
    /// @param _input The deploy input parameters for the deployment.
    /// @return The deploy output values of the deployment.
    function deploy(DeployInput calldata _input) external virtual returns (DeployOutput memory) {
        return opcmDeployer.deploy(_input, superchainConfig, msg.sender);
    }

    /// @notice Upgrades a set of chains to the latest implementation contracts
    /// @param _opChainConfigs Array of OpChain structs, one per chain to upgrade
    /// @dev This function is intended to be DELEGATECALLed by an address that is the common owner of every chain in
    ///      `_opChainConfigs`'s ProxyAdmin.
    /// @dev This function requires that each chain's superchainConfig is already upgraded.
    function upgrade(OpChainConfig[] memory _opChainConfigs) external virtual {
        if (address(this) == address(thisOPCM)) revert OnlyDelegatecall();

        bytes memory data = abi.encodeCall(OPContractsManagerUpgrader.upgrade, (_opChainConfigs));
        _performDelegateCall(address(opcmUpgrader), data);
    }

    /// @notice Upgrades the SuperchainConfig contract.
    /// @param _superchainConfig The SuperchainConfig contract to upgrade.
    /// @param _superchainProxyAdmin The ProxyAdmin contract to use for the upgrade.
    /// @dev This function is intended to be DELEGATECALLed by the superchainConfig's ProxyAdminOwner.
    /// @dev This function will revert if the SuperchainConfig is already at or above the target version.
    function upgradeSuperchainConfig(ISuperchainConfig _superchainConfig, IProxyAdmin _superchainProxyAdmin) external {
        if (address(this) == address(thisOPCM)) revert OnlyDelegatecall();

        bytes memory data = abi.encodeCall(
            OPContractsManagerUpgrader.upgradeSuperchainConfig, (_superchainConfig, _superchainProxyAdmin)
        );
        _performDelegateCall(address(opcmUpgrader), data);
    }

    /// @notice addGameType deploys a new dispute game and links it to the DisputeGameFactory. The inputted _gameConfigs
    /// must be added in ascending GameType order.
    function addGameType(AddGameInput[] memory _gameConfigs) public virtual returns (AddGameOutput[] memory) {
        if (address(this) == address(thisOPCM)) revert OnlyDelegatecall();

        bytes memory data = abi.encodeCall(OPContractsManagerGameTypeAdder.addGameType, (_gameConfigs));

        bytes memory returnData = _performDelegateCall(address(opcmGameTypeAdder), data);
        return abi.decode(returnData, (AddGameOutput[]));
    }

    /// @notice Updates the prestate hash for dispute games while keeping all other parameters the same
    /// @param _prestateUpdateInputs The new prestate hashes to use
    function updatePrestate(UpdatePrestateInput[] memory _prestateUpdateInputs) public {
        if (address(this) == address(thisOPCM)) revert OnlyDelegatecall();

        bytes memory data = abi.encodeCall(OPContractsManagerGameTypeAdder.updatePrestate, (_prestateUpdateInputs));

        _performDelegateCall(address(opcmGameTypeAdder), data);
    }

    /// @notice Migrates the Optimism contracts to the latest version.
    /// @param _input Input parameters for the migration.
    function migrate(OPContractsManagerInteropMigrator.MigrateInput calldata _input) external virtual {
        if (address(this) == address(thisOPCM)) revert OnlyDelegatecall();

        bytes memory data = abi.encodeCall(OPContractsManagerInteropMigrator.migrate, (_input));
        _performDelegateCall(address(opcmInteropMigrator), data);
    }

    /// @notice Maps an L2 chain ID to an L1 batch inbox address as defined by the standard
    /// configuration's convention. This convention is `versionByte || keccak256(bytes32(chainId))[:19]`,
    /// where || denotes concatenation`, versionByte is 0x00, and chainId is a uint256.
    /// https://specs.optimism.io/protocol/configurability.html#consensus-parameters
    function chainIdToBatchInboxAddress(uint256 _l2ChainId) public view returns (address) {
        return opcmDeployer.chainIdToBatchInboxAddress(_l2ChainId);
    }

    /// @notice Returns the blueprint contract addresses.
    function blueprints() public view returns (Blueprints memory) {
        return opcmDeployer.blueprints();
    }

    /// @notice Returns the implementation contract addresses.
    function implementations() public view returns (Implementations memory) {
        return opcmDeployer.implementations();
    }

    /// @notice Retrieves the development feature bitmap stored in this OPCM contract
    /// @return The development feature bitmap.
    function devFeatureBitmap() public view returns (bytes32) {
        return opcmDeployer.devFeatureBitmap();
    }

    /// @notice Returns the status of a development feature. Note that this function does not check
    ///         that the input feature represents a single feature and the bitwise AND operation
    ///         allows for multiple features to be enabled at once. Users should generally check
    ///         for only a single feature at a time.
    /// @param _feature The feature to check.
    /// @return True if the feature is enabled, false otherwise.
    function isDevFeatureEnabled(bytes32 _feature) public view returns (bool) {
        return opcmDeployer.isDevFeatureEnabled(_feature);
    }

    /// @notice Helper function to perform a delegatecall to a target contract
    /// @param _target The target contract address
    /// @param _data The calldata to send to the target
    /// @return bytes The return data from the delegatecall
    function _performDelegateCall(address _target, bytes memory _data) internal returns (bytes memory) {
        // Perform the delegatecall
        (bool success, bytes memory returnData) = _target.delegatecall(_data);

        // Check if the delegatecall was successful
        if (!success) {
            // If there was a revert message, bubble it up
            assembly {
                revert(add(returnData, 32), mload(returnData))
            }
        }

        return returnData;
    }
}
